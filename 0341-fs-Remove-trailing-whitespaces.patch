From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Elyes Haouas <ehaouas@noos.fr>
Date: Fri, 4 Mar 2022 07:41:59 +0100
Subject: [PATCH] fs: Remove trailing whitespaces

Signed-off-by: Elyes Haouas <ehaouas@noos.fr>
Reviewed-by: Daniel Kiper <daniel.kiper@oracle.com>
---
 grub-core/fs/affs.c             |   4 +-
 grub-core/fs/archelp.c          |   4 +-
 grub-core/fs/bfs.c              |  10 +-
 grub-core/fs/cpio_common.c      |   2 +-
 grub-core/fs/fat.c              |   6 +-
 grub-core/fs/fshelp.c           |   6 +-
 grub-core/fs/hfs.c              |  14 +--
 grub-core/fs/hfsplus.c          |   8 +-
 grub-core/fs/hfspluscomp.c      |   6 +-
 grub-core/fs/iso9660.c          |  12 +--
 grub-core/fs/minix.c            |   6 +-
 grub-core/fs/nilfs2.c           |   8 +-
 grub-core/fs/ntfs.c             |   8 +-
 grub-core/fs/reiserfs.c         |   2 +-
 grub-core/fs/romfs.c            |   8 +-
 grub-core/fs/squash4.c          |  26 ++---
 grub-core/fs/udf.c              |   2 +-
 grub-core/fs/ufs.c              |   4 +-
 grub-core/fs/xfs.c              |   2 +-
 grub-core/fs/zfs/zfs.c          | 224 ++++++++++++++++++++--------------------
 grub-core/fs/zfs/zfs_fletcher.c |  12 +--
 grub-core/fs/zfs/zfs_sha256.c   |  14 +--
 grub-core/fs/zfs/zfscrypt.c     |  14 +--
 23 files changed, 201 insertions(+), 201 deletions(-)

diff --git a/grub-core/fs/affs.c b/grub-core/fs/affs.c
index cafcd0fba916..0d90e9d1a895 100644
--- a/grub-core/fs/affs.c
+++ b/grub-core/fs/affs.c
@@ -345,7 +345,7 @@ grub_affs_create_node (grub_fshelp_node_t dir,
   if (len > sizeof (fil->name))
     len = sizeof (fil->name);
   *grub_latin1_to_utf8 (name_u8, fil->name, len) = '\0';
-  
+
   (*node)->di = *fil;
   for (nest = 0; nest < 8; nest++)
     {
@@ -408,7 +408,7 @@ grub_affs_iterate_dir (grub_fshelp_node_t dir,
   node = orig_node = grub_zalloc (sizeof (*node));
   if (!node)
     return 1;
-    
+
   *node = *dir;
   if (hook (".", GRUB_FSHELP_DIR, node, hook_data))
     return 1;
diff --git a/grub-core/fs/archelp.c b/grub-core/fs/archelp.c
index 0cf544f6fdfe..998de88b865c 100644
--- a/grub-core/fs/archelp.c
+++ b/grub-core/fs/archelp.c
@@ -75,7 +75,7 @@ handle_symlink (struct grub_archelp_data *data,
       || !arcops->get_link_target)
     return GRUB_ERR_NONE;
   flen = grub_strlen (fn);
-  if (grub_memcmp (*name, fn, flen) != 0 
+  if (grub_memcmp (*name, fn, flen) != 0
       || ((*name)[flen] != 0 && (*name)[flen] != '/'))
     return GRUB_ERR_NONE;
   rest = *name + flen;
@@ -251,7 +251,7 @@ grub_archelp_open (struct grub_archelp_data *data,
       grub_uint32_t mode;
       grub_int32_t mtime;
       int restart;
-      
+
       if (arcops->find_file (data, &fn, &mtime, &mode))
 	goto fail;
 
diff --git a/grub-core/fs/bfs.c b/grub-core/fs/bfs.c
index 47dbe2011a14..a75876010d30 100644
--- a/grub-core/fs/bfs.c
+++ b/grub-core/fs/bfs.c
@@ -530,13 +530,13 @@ iterate_in_b_tree (grub_disk_t disk,
       err = read_b_node (disk, sb, ino,
 			 node_off,
 			 &node,
-			 &key_data, 
+			 &key_data,
 			 &keylen_idx,
 			 &key_values);
 
       if (err)
 	return 0;
-      
+
       for (i = 0; i < grub_bfs_to_cpu_treehead (node->count_keys); i++)
 	{
 	  char c;
@@ -682,7 +682,7 @@ find_in_b_tree (grub_disk_t disk,
 		level--;
 		grub_free (node);
 		continue;
-	      }	      
+	      }
 	  }
 	else if (level != 0
 		 && i + 1 < grub_bfs_to_cpu_treehead (node->count_keys))
@@ -827,7 +827,7 @@ mount (grub_disk_t disk, struct grub_bfs_superblock *sb)
   grub_err_t err;
   err = grub_disk_read (disk, SUPERBLOCK, 0, sizeof (*sb), sb);
   if (err == GRUB_ERR_OUT_OF_RANGE)
-    return grub_error (GRUB_ERR_BAD_FS, 
+    return grub_error (GRUB_ERR_BAD_FS,
 #ifdef MODE_AFS
 		       "not an AFS filesystem"
 #else
@@ -843,7 +843,7 @@ mount (grub_disk_t disk, struct grub_bfs_superblock *sb)
       || (grub_bfs_to_cpu32 (sb->bsize)
 	  != (1U << grub_bfs_to_cpu32 (sb->log2_bsize)))
       || grub_bfs_to_cpu32 (sb->log2_bsize) < GRUB_DISK_SECTOR_BITS)
-    return grub_error (GRUB_ERR_BAD_FS, 
+    return grub_error (GRUB_ERR_BAD_FS,
 #ifdef MODE_AFS
 		       "not an AFS filesystem"
 #else
diff --git a/grub-core/fs/cpio_common.c b/grub-core/fs/cpio_common.c
index 4e885d62313e..5d41b6fdbe1c 100644
--- a/grub-core/fs/cpio_common.c
+++ b/grub-core/fs/cpio_common.c
@@ -117,7 +117,7 @@ grub_cpio_get_link_target (struct grub_archelp_data *data)
   if (!ret)
     return NULL;
 
-  err = grub_disk_read (data->disk, 0, data->dofs, data->size, 
+  err = grub_disk_read (data->disk, 0, data->dofs, data->size,
 			ret);
   if (err)
     {
diff --git a/grub-core/fs/fat.c b/grub-core/fs/fat.c
index ff6200c5be5d..c5efed724124 100644
--- a/grub-core/fs/fat.c
+++ b/grub-core/fs/fat.c
@@ -246,7 +246,7 @@ grub_fat_mount (grub_disk_t disk)
 #ifdef MODE_EXFAT
   if (grub_memcmp ((const char *) bpb.oem_name, "EXFAT   ",
 		   sizeof (bpb.oem_name)) != 0)
-    goto fail;    
+    goto fail;
 #endif
 
   /* Get the sizes of logical sectors and clusters.  */
@@ -321,7 +321,7 @@ grub_fat_mount (grub_disk_t disk)
 #endif
 
 #ifdef MODE_EXFAT
-  data->cluster_sector = (grub_le_to_cpu32 (bpb.cluster_offset) 
+  data->cluster_sector = (grub_le_to_cpu32 (bpb.cluster_offset)
 			  << data->logical_sector_bits);
   data->num_clusters = (grub_le_to_cpu32 (bpb.cluster_count)
 			  << data->logical_sector_bits);
@@ -694,7 +694,7 @@ grub_fat_iterate_dir_next (grub_fshelp_node_t node,
 		  {
 		    int j;
 		    for (j = 0; j < 15; j++)
-		      ctxt->unibuf[slots * 15 + j] 
+		      ctxt->unibuf[slots * 15 + j]
 			= grub_le_to_cpu16 (sec.type_specific.file_name.str[j]);
 		    slots++;
 		  }
diff --git a/grub-core/fs/fshelp.c b/grub-core/fs/fshelp.c
index a2d0d297a520..cb41934b4fec 100644
--- a/grub-core/fs/fshelp.c
+++ b/grub-core/fs/fshelp.c
@@ -215,7 +215,7 @@ find_file (char *currpath,
 	break;
 
       push_node (ctx, foundnode, foundtype);
- 
+
       /* Read in the symlink and follow it.  */
       if (ctx->currnode->type == GRUB_FSHELP_SYMLINK)
 	{
@@ -326,7 +326,7 @@ grub_fshelp_find_file (const char *path, grub_fshelp_node_t rootnode,
 		       enum grub_fshelp_filetype expecttype)
 {
   return grub_fshelp_find_file_real (path, rootnode, foundnode,
-				     iterate_dir, NULL, 
+				     iterate_dir, NULL,
 				     read_symlink, expecttype);
 
 }
@@ -339,7 +339,7 @@ grub_fshelp_find_file_lookup (const char *path, grub_fshelp_node_t rootnode,
 			      enum grub_fshelp_filetype expecttype)
 {
   return grub_fshelp_find_file_real (path, rootnode, foundnode,
-				     NULL, lookup_file, 
+				     NULL, lookup_file,
 				     read_symlink, expecttype);
 
 }
diff --git a/grub-core/fs/hfs.c b/grub-core/fs/hfs.c
index f419965d154f..91dc0e69c3de 100644
--- a/grub-core/fs/hfs.c
+++ b/grub-core/fs/hfs.c
@@ -883,7 +883,7 @@ grub_hfs_iterate_dir_it_dir (struct grub_hfs_node *hnd __attribute ((unused)),
 {
   struct grub_hfs_catalog_key *ckey = rec->key;
   struct grub_hfs_iterate_dir_node_found_ctx *ctx = hook_arg;
-  
+
   /* Stop when the entries do not match anymore.  */
   if (ckey->parent_dir != ctx->dir_be)
     return 1;
@@ -1077,7 +1077,7 @@ macroman_to_utf8 (char *to, const grub_uint8_t *from, grub_size_t len,
 	{
 	  *optr++ = ':';
 	  continue;
-	}	
+	}
       if (!(*iptr & 0x80))
 	{
 	  *optr++ = *iptr;
@@ -1094,7 +1094,7 @@ utf8_to_macroman (grub_uint8_t *to, const char *from)
   grub_uint8_t *end = to + 31;
   grub_uint8_t *optr = to;
   const char *iptr = from;
-  
+
   while (*iptr && optr < end)
     {
       int i, clen;
@@ -1104,7 +1104,7 @@ utf8_to_macroman (grub_uint8_t *to, const char *from)
 	  *optr++ = '/';
 	  iptr++;
 	  continue;
-	}	
+	}
       if (!(*iptr & 0x80))
 	{
 	  *optr++ = *iptr++;
@@ -1165,7 +1165,7 @@ lookup_file (grub_fshelp_node_t dir,
   *foundnode = grub_malloc (sizeof (struct grub_fshelp_node));
   if (!*foundnode)
     return grub_errno;
-  
+
   (*foundnode)->inode = grub_be_to_cpu32 (fdrec.dir.dirid);
   (*foundnode)->fdrec = fdrec;
   (*foundnode)->data = dir->data;
@@ -1266,7 +1266,7 @@ grub_hfs_dir (grub_device_t device, const char *path, grub_fs_dir_hook_t hook,
       .hook_data = hook_data
     };
   grub_fshelp_node_t found = NULL;
-  
+
   grub_dl_ref (my_mod);
 
   data = grub_hfs_mount (device->disk);
@@ -1295,7 +1295,7 @@ grub_hfs_open (struct grub_file *file, const char *name)
 {
   struct grub_hfs_data *data;
   grub_fshelp_node_t found = NULL;
-  
+
   grub_dl_ref (my_mod);
 
   data = grub_hfs_mount (file->device->disk);
diff --git a/grub-core/fs/hfsplus.c b/grub-core/fs/hfsplus.c
index 19c7b3367987..6337cbfcbec6 100644
--- a/grub-core/fs/hfsplus.c
+++ b/grub-core/fs/hfsplus.c
@@ -19,7 +19,7 @@
 
 /* HFS+ is documented at http://developer.apple.com/technotes/tn/tn1150.html */
 
-#define grub_fshelp_node grub_hfsplus_file 
+#define grub_fshelp_node grub_hfsplus_file
 #include <grub/err.h>
 #include <grub/file.h>
 #include <grub/mm.h>
@@ -146,7 +146,7 @@ grub_hfsplus_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)
 {
   struct grub_hfsplus_btnode *nnode = 0;
   grub_disk_addr_t blksleft = fileblock;
-  struct grub_hfsplus_extent *extents = node->compressed 
+  struct grub_hfsplus_extent *extents = node->compressed
     ? &node->resource_extents[0] : &node->extents[0];
 
   while (1)
@@ -477,7 +477,7 @@ grub_hfsplus_cmp_extkey (struct grub_hfsplus_key *keya,
 
   if (extkey_a->type < extkey_b->type)
     return -1;
-  
+
   akey = grub_be_to_cpu32 (extkey_a->start);
   if (akey > extkey_b->start)
     return 1;
@@ -568,7 +568,7 @@ grub_hfsplus_btree_search (struct grub_hfsplus_btree *btree,
 			   struct grub_hfsplus_key_internal *key,
 			   int (*compare_keys) (struct grub_hfsplus_key *keya,
 						struct grub_hfsplus_key_internal *keyb),
-			   struct grub_hfsplus_btnode **matchnode, 
+			   struct grub_hfsplus_btnode **matchnode,
 			   grub_off_t *keyoffset)
 {
   grub_uint64_t currnode;
diff --git a/grub-core/fs/hfspluscomp.c b/grub-core/fs/hfspluscomp.c
index d76f3f137a92..095ea48c9a62 100644
--- a/grub-core/fs/hfspluscomp.c
+++ b/grub-core/fs/hfspluscomp.c
@@ -179,7 +179,7 @@ hfsplus_read_compressed_real (struct grub_hfsplus_file *node,
   return len0;
 }
 
-static grub_err_t 
+static grub_err_t
 hfsplus_open_compressed_real (struct grub_hfsplus_file *node)
 {
   grub_err_t err;
@@ -306,8 +306,8 @@ hfsplus_open_compressed_real (struct grub_hfsplus_file *node)
 
 GRUB_MOD_INIT(hfspluscomp)
 {
-  grub_hfsplus_open_compressed = hfsplus_open_compressed_real;  
-  grub_hfsplus_read_compressed = hfsplus_read_compressed_real;  
+  grub_hfsplus_open_compressed = hfsplus_open_compressed_real;
+  grub_hfsplus_read_compressed = hfsplus_read_compressed_real;
 }
 
 GRUB_MOD_FINI(hfspluscomp)
diff --git a/grub-core/fs/iso9660.c b/grub-core/fs/iso9660.c
index ac011950a64f..91817ec1f5ad 100644
--- a/grub-core/fs/iso9660.c
+++ b/grub-core/fs/iso9660.c
@@ -181,7 +181,7 @@ static grub_err_t
 iso9660_to_unixtime (const struct grub_iso9660_date *i, grub_int64_t *nix)
 {
   struct grub_datetime datetime;
-  
+
   if (! i->year[0] && ! i->year[1]
       && ! i->year[2] && ! i->year[3]
       && ! i->month[0] && ! i->month[1]
@@ -198,7 +198,7 @@ iso9660_to_unixtime (const struct grub_iso9660_date *i, grub_int64_t *nix)
   datetime.hour = (i->hour[0] - '0') * 10 + (i->hour[1] - '0');
   datetime.minute = (i->minute[0] - '0') * 10 + (i->minute[1] - '0');
   datetime.second = (i->second[0] - '0') * 10 + (i->second[1] - '0');
-  
+
   if (!grub_datetime2unixtime (&datetime, nix))
     return grub_error (GRUB_ERR_BAD_NUMBER, "incorrect date");
   *nix -= i->offset * 60 * 15;
@@ -216,7 +216,7 @@ iso9660_to_unixtime2 (const struct grub_iso9660_date2 *i, grub_int64_t *nix)
   datetime.hour = i->hour;
   datetime.minute = i->minute;
   datetime.second = i->second;
-  
+
   if (!grub_datetime2unixtime (&datetime, nix))
     return 0;
   *nix -= i->offset * 60 * 15;
@@ -499,7 +499,7 @@ grub_iso9660_mount (grub_disk_t disk)
 static char *
 grub_iso9660_read_symlink (grub_fshelp_node_t node)
 {
-  return node->have_symlink 
+  return node->have_symlink
     ? grub_strdup (node->symlink
 		   + (node->have_dirents) * sizeof (node->dirents[0])
 		   - sizeof (node->dirents)) : grub_strdup ("");
@@ -549,7 +549,7 @@ add_part (struct iterate_dir_ctx *ctx,
   ctx->symlink = new;
 
   grub_memcpy (ctx->symlink + size, part, len2);
-  ctx->symlink[size + len2] = 0;  
+  ctx->symlink[size + len2] = 0;
 }
 
 static grub_err_t
@@ -1106,7 +1106,7 @@ grub_iso9660_uuid (grub_device_t device, char **uuid)
 }
 
 /* Get writing time of filesystem. */
-static grub_err_t 
+static grub_err_t
 grub_iso9660_mtime (grub_device_t device, grub_int64_t *timebuf)
 {
   struct grub_iso9660_data *data;
diff --git a/grub-core/fs/minix.c b/grub-core/fs/minix.c
index 3cd18c85b302..953df11916b8 100644
--- a/grub-core/fs/minix.c
+++ b/grub-core/fs/minix.c
@@ -98,10 +98,10 @@ struct grub_minix_sblock
   grub_uint32_t max_file_size;
   grub_uint32_t zones;
   grub_uint16_t magic;
-  
+
   grub_uint16_t pad2;
   grub_uint16_t block_size;
-  grub_uint8_t disk_version; 
+  grub_uint8_t disk_version;
 };
 #else
 struct grub_minix_sblock
@@ -351,7 +351,7 @@ grub_minix_read_inode (struct grub_minix_data *data, grub_minix_ino_t ino)
   int offs = (ino % (GRUB_DISK_SECTOR_SIZE
 		     / sizeof (struct grub_minix_inode))
 	      * sizeof (struct grub_minix_inode));
-  
+
   grub_disk_read (data->disk, block, offs,
 		  sizeof (struct grub_minix_inode), &data->inode);
 
diff --git a/grub-core/fs/nilfs2.c b/grub-core/fs/nilfs2.c
index 3c248a910b42..fc7374ead490 100644
--- a/grub-core/fs/nilfs2.c
+++ b/grub-core/fs/nilfs2.c
@@ -1,5 +1,5 @@
-/* 
- *  nilfs2.c - New Implementation of Log filesystem 
+/*
+ *  nilfs2.c - New Implementation of Log filesystem
  *
  *  Written by Jiro SEKIBA <jir@unicus.jp>
  *
@@ -680,12 +680,12 @@ grub_nilfs2_read_checkpoint (struct grub_nilfs2_data *data,
   grub_disk_t disk = data->disk;
   unsigned int nilfs2_block_count = (1 << LOG2_NILFS2_BLOCK_SIZE (data));
 
-  /* Assume sizeof(struct grub_nilfs2_cpfile_header) < 
+  /* Assume sizeof(struct grub_nilfs2_cpfile_header) <
      sizeof(struct grub_nilfs2_checkpoint).
    */
   blockno = grub_divmod64 (cpno, NILFS2_BLOCK_SIZE (data) /
                           sizeof (struct grub_nilfs2_checkpoint), &offset);
-  
+
   pptr = grub_nilfs2_bmap_lookup (data, &data->sroot.sr_cpfile, blockno, 1);
   if (pptr == (grub_uint64_t) - 1)
     {
diff --git a/grub-core/fs/ntfs.c b/grub-core/fs/ntfs.c
index 2f34f76da88c..3511e4e2cb6f 100644
--- a/grub-core/fs/ntfs.c
+++ b/grub-core/fs/ntfs.c
@@ -17,7 +17,7 @@
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#define grub_fshelp_node grub_ntfs_file 
+#define grub_fshelp_node grub_ntfs_file
 
 #include <grub/file.h>
 #include <grub/mm.h>
@@ -32,7 +32,7 @@ GRUB_MOD_LICENSE ("GPLv3+");
 
 static grub_dl_t my_mod;
 
-#define grub_fshelp_node grub_ntfs_file 
+#define grub_fshelp_node grub_ntfs_file
 
 static inline grub_uint16_t
 u16at (void *ptr, grub_size_t ofs)
@@ -725,7 +725,7 @@ grub_ntfs_read_symlink (grub_fshelp_node_t node)
       && grub_isalpha (buf[4]))
     {
       grub_memmove (buf, buf + 6, end - buf + 1 - 6);
-      end -= 6; 
+      end -= 6;
     }
   return buf;
 }
@@ -992,7 +992,7 @@ grub_ntfs_dir_iter (const char *filename, enum grub_fshelp_filetype filetype,
   grub_memset (&info, 0, sizeof (info));
   info.dir = ((filetype & GRUB_FSHELP_TYPE_MASK) == GRUB_FSHELP_DIR);
   info.mtimeset = 1;
-  info.mtime = grub_divmod64 (node->mtime, 10000000, 0) 
+  info.mtime = grub_divmod64 (node->mtime, 10000000, 0)
     - 86400ULL * 365 * (1970 - 1601)
     - 86400ULL * ((1970 - 1601) / 4) + 86400ULL * ((1970 - 1601) / 100);
   grub_free (node);
diff --git a/grub-core/fs/reiserfs.c b/grub-core/fs/reiserfs.c
index b8253da7fed2..42818c376229 100644
--- a/grub-core/fs/reiserfs.c
+++ b/grub-core/fs/reiserfs.c
@@ -775,7 +775,7 @@ grub_reiserfs_iterate_dir (grub_fshelp_node_t item,
 	  char *entry_name;
 	  char *entry_name_end = 0;
 	  char c;
-	  
+
           if (!(entry_state & GRUB_REISERFS_VISIBLE_MASK))
 	    continue;
 
diff --git a/grub-core/fs/romfs.c b/grub-core/fs/romfs.c
index d97b8fbb8c36..1f7dcfca1d3a 100644
--- a/grub-core/fs/romfs.c
+++ b/grub-core/fs/romfs.c
@@ -112,7 +112,7 @@ grub_romfs_mount (grub_device_t dev)
     {
       grub_error (GRUB_ERR_BAD_FS, "not romfs");
       return NULL;
-    }    
+    }
   err = do_checksum (&sb, sizeof (sb) < grub_be_to_cpu32 (sb.sb.total_size) ?
 		     sizeof (sb) : grub_be_to_cpu32 (sb.sb.total_size));
   if (err)
@@ -271,7 +271,7 @@ grub_romfs_iterate_dir (grub_fshelp_node_t dir,
 		while (1)
 		  {
 		    char buf[16];
-		    err = grub_disk_read (dir->data->disk, 
+		    err = grub_disk_read (dir->data->disk,
 					  laddr >> GRUB_DISK_SECTOR_BITS,
 					  laddr & (GRUB_DISK_SECTOR_SIZE - 1),
 					  16, buf);
@@ -298,7 +298,7 @@ grub_romfs_iterate_dir (grub_fshelp_node_t dir,
 		node->data_addr = grub_be_to_cpu32 (node->file.spec);
 		filetype = GRUB_FSHELP_DIR;
 	      }
-	    
+
 	    break;
 	  }
 	}
@@ -402,7 +402,7 @@ grub_romfs_read (grub_file_t file, char *buf, grub_size_t len)
   data->data->disk->read_hook_data = file->read_hook_data;
   grub_disk_read (data->data->disk,
 		  (data->data_addr + file->offset) >> GRUB_DISK_SECTOR_BITS,
-		  (data->data_addr + file->offset) & (GRUB_DISK_SECTOR_SIZE - 1),		  
+		  (data->data_addr + file->offset) & (GRUB_DISK_SECTOR_SIZE - 1),
 		  len, buf);
   data->data->disk->read_hook = NULL;
 
diff --git a/grub-core/fs/squash4.c b/grub-core/fs/squash4.c
index 6dd731e231ee..02b1f9b6d101 100644
--- a/grub-core/fs/squash4.c
+++ b/grub-core/fs/squash4.c
@@ -210,7 +210,7 @@ struct grub_fshelp_node
   struct grub_squash_data *data;
   struct grub_squash_inode ino;
   grub_size_t stsize;
-  struct 
+  struct
   {
     grub_disk_addr_t ino_chunk;
     grub_uint16_t ino_offset;
@@ -243,7 +243,7 @@ read_chunk (struct grub_squash_data *data, void *buf, grub_size_t len,
       csize = SQUASH_CHUNK_SIZE - offset;
       if (csize > len)
 	csize = len;
-  
+
       if (grub_le_to_cpu16 (d) & SQUASH_CHUNK_UNCOMPRESSED)
 	{
 	  grub_disk_addr_t a = chunk_start + 2 + offset;
@@ -256,7 +256,7 @@ read_chunk (struct grub_squash_data *data, void *buf, grub_size_t len,
       else
 	{
 	  char *tmp;
-	  grub_size_t bsize = grub_le_to_cpu16 (d) & ~SQUASH_CHUNK_FLAGS; 
+	  grub_size_t bsize = grub_le_to_cpu16 (d) & ~SQUASH_CHUNK_FLAGS;
 	  grub_disk_addr_t a = chunk_start + 2;
 	  tmp = grub_malloc (bsize);
 	  if (!tmp)
@@ -339,7 +339,7 @@ xz_decompress (char *inbuf, grub_size_t insize, grub_off_t off,
   while (len)
     {
       enum xz_ret xzret;
-      
+
       buf.out_pos = 0;
 
       xzret = xz_dec_run (data->xzdec, &buf);
@@ -399,9 +399,9 @@ squash_mount (grub_disk_t disk)
       return NULL;
     }
 
-  err = grub_disk_read (disk, 
+  err = grub_disk_read (disk,
 			grub_le_to_cpu64 (sb.unk1offset)
-			>> GRUB_DISK_SECTOR_BITS, 
+			>> GRUB_DISK_SECTOR_BITS,
 			grub_le_to_cpu64 (sb.unk1offset)
 			& (GRUB_DISK_SECTOR_SIZE - 1), sizeof (frag), &frag);
   if (grub_errno == GRUB_ERR_OUT_OF_RANGE)
@@ -448,7 +448,7 @@ squash_mount (grub_disk_t disk)
     }
 
   data->blksz = grub_le_to_cpu32 (data->sb.block_size);
-  for (data->log2_blksz = 0; 
+  for (data->log2_blksz = 0;
        (1U << data->log2_blksz) < data->blksz;
        data->log2_blksz++);
 
@@ -643,7 +643,7 @@ make_root_node (struct grub_squash_data *data, struct grub_fshelp_node *root)
   root->stack[0].ino_chunk = grub_le_to_cpu32 (data->sb.root_ino_chunk);
   root->stack[0].ino_offset = grub_cpu_to_le16 (data->sb.root_ino_offset);
  return read_chunk (data, &root->ino, sizeof (root->ino),
-		    grub_le_to_cpu64 (data->sb.inodeoffset) 
+		    grub_le_to_cpu64 (data->sb.inodeoffset)
 		    + root->stack[0].ino_chunk,
 		    root->stack[0].ino_offset);
 }
@@ -765,7 +765,7 @@ grub_squash_open (struct grub_file *file, const char *name)
 }
 
 static grub_ssize_t
-direct_read (struct grub_squash_data *data, 
+direct_read (struct grub_squash_data *data,
 	     struct grub_squash_cache_inode *ino,
 	     grub_off_t off, char *buf, grub_size_t len)
 {
@@ -882,7 +882,7 @@ direct_read (struct grub_squash_data *data,
 	  grub_free (block);
 	}
       else
-	err = grub_disk_read (data->disk, 
+	err = grub_disk_read (data->disk,
 			      (ino->cumulated_block_sizes[i] + a + boff)
 			      >> GRUB_DISK_SECTOR_BITS,
 			      (ino->cumulated_block_sizes[i] + a + boff)
@@ -946,7 +946,7 @@ grub_squash_read (grub_file_t file, char *buf, grub_size_t len)
     }
   else
     off -= direct_len;
- 
+
   err = read_chunk (data, &frag, sizeof (frag),
 		    data->fragments, sizeof (frag) * fragment);
   if (err)
@@ -957,7 +957,7 @@ grub_squash_read (grub_file_t file, char *buf, grub_size_t len)
     b = grub_le_to_cpu32 (ino->ino.long_file.offset) + off;
   else
     b = grub_le_to_cpu32 (ino->ino.file.offset) + off;
-  
+
   /* FIXME: cache uncompressed chunks.  */
   if (compressed)
     {
@@ -1013,7 +1013,7 @@ grub_squash_mtime (grub_device_t dev, grub_int64_t *tm)
   *tm = grub_le_to_cpu32 (data->sb.creation_time);
   squash_unmount (data);
   return GRUB_ERR_NONE;
-} 
+}
 
 static struct grub_fs grub_squash_fs =
   {
diff --git a/grub-core/fs/udf.c b/grub-core/fs/udf.c
index 2ac5c1d0048f..5a665093ed77 100644
--- a/grub-core/fs/udf.c
+++ b/grub-core/fs/udf.c
@@ -567,7 +567,7 @@ grub_udf_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)
 		    (buf + sizeof (struct grub_udf_aed));
 	      continue;
 	    }
-	      
+
 	  if (filebytes < adlen)
 	    {
 	      grub_uint32_t ad_block_num = ad->block.block_num;
diff --git a/grub-core/fs/ufs.c b/grub-core/fs/ufs.c
index 34a698b71b8d..a354c92d936a 100644
--- a/grub-core/fs/ufs.c
+++ b/grub-core/fs/ufs.c
@@ -568,7 +568,7 @@ grub_ufs_find_file (struct grub_ufs_data *data, const char *path)
 	    {
 	      dirino = data->ino;
 	      grub_ufs_read_inode (data, grub_ufs_to_cpu32 (dirent.ino), 0);
-	      
+
 	      if ((INODE_MODE(data) & GRUB_UFS_ATTR_TYPE)
 		  == GRUB_UFS_ATTR_LNK)
 		{
@@ -613,7 +613,7 @@ grub_ufs_mount (grub_disk_t disk)
 	  && ((data->sblock.bsize & (data->sblock.bsize - 1)) == 0)
 	  && data->sblock.ino_per_group != 0)
 	{
-	  for (data->log2_blksz = 0; 
+	  for (data->log2_blksz = 0;
 	       (1U << data->log2_blksz) < grub_ufs_to_cpu32 (data->sblock.bsize);
 	       data->log2_blksz++);
 
diff --git a/grub-core/fs/xfs.c b/grub-core/fs/xfs.c
index e3816d1ec4a9..d6de7f1a2dd2 100644
--- a/grub-core/fs/xfs.c
+++ b/grub-core/fs/xfs.c
@@ -894,7 +894,7 @@ grub_xfs_iterate_dir (grub_fshelp_node_t dir,
 		   tag, which is not used by GRUB.  So it can be overwritten. */
 		filename[direntry->len] = '\0';
 
-		if (iterate_dir_call_hook (grub_be_to_cpu64(direntry->inode), 
+		if (iterate_dir_call_hook (grub_be_to_cpu64(direntry->inode),
 					   filename, &ctx))
 		  {
 		    grub_free (dirblock);
diff --git a/grub-core/fs/zfs/zfs.c b/grub-core/fs/zfs/zfs.c
index cf4d2ab189a5..5961818abc9a 100644
--- a/grub-core/fs/zfs/zfs.c
+++ b/grub-core/fs/zfs/zfs.c
@@ -176,7 +176,7 @@ typedef struct decomp_entry
 /*
  * Signature for checksum functions.
  */
-typedef void zio_checksum_t(const void *data, grub_uint64_t size, 
+typedef void zio_checksum_t(const void *data, grub_uint64_t size,
 			    grub_zfs_endian_t endian, zio_cksum_t *zcp);
 
 /*
@@ -297,7 +297,7 @@ check_feature(const char *name, grub_uint64_t val, struct grub_zfs_dir_ctx *ctx)
 static grub_err_t
 check_mos_features(dnode_phys_t *mosmdn_phys,grub_zfs_endian_t endian,struct grub_zfs_data* data );
 
-static grub_err_t 
+static grub_err_t
 zlib_decompress (void *s, void *d,
 		 grub_size_t slen, grub_size_t dlen)
 {
@@ -310,7 +310,7 @@ zlib_decompress (void *s, void *d,
   return grub_errno;
 }
 
-static grub_err_t 
+static grub_err_t
 zle_decompress (void *s, void *d,
 		grub_size_t slen, grub_size_t dlen)
 {
@@ -415,7 +415,7 @@ static zio_checksum_info_t zio_checksum_table[ZIO_CHECKSUM_FUNCTIONS] = {
  */
 static grub_err_t
 zio_checksum_verify (zio_cksum_t zc, grub_uint32_t checksum,
-		     grub_zfs_endian_t endian, 
+		     grub_zfs_endian_t endian,
 		     char *buf, grub_size_t size)
 {
   zio_eck_t *zec = (zio_eck_t *) (buf + size) - 1;
@@ -425,14 +425,14 @@ zio_checksum_verify (zio_cksum_t zc, grub_uint32_t checksum,
   if (checksum >= ZIO_CHECKSUM_FUNCTIONS || ci->ci_func == NULL)
     {
       grub_dprintf ("zfs", "unknown checksum function %d\n", checksum);
-      return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET, 
+      return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
 			 "unknown checksum function %d", checksum);
     }
 
   if (ci->ci_eck)
     {
-      expected_cksum = zec->zec_cksum;  
-      zec->zec_cksum = zc;  
+      expected_cksum = zec->zec_cksum;
+      zec->zec_cksum = zc;
       ci->ci_func (buf, size, endian, &actual_cksum);
       zec->zec_cksum = expected_cksum;
       zc = expected_cksum;
@@ -445,14 +445,14 @@ zio_checksum_verify (zio_cksum_t zc, grub_uint32_t checksum,
     {
       grub_dprintf ("zfs", "checksum %s verification failed\n", ci->ci_name);
       grub_dprintf ("zfs", "actual checksum %016llx %016llx %016llx %016llx\n",
-		    (unsigned long long) actual_cksum.zc_word[0], 
+		    (unsigned long long) actual_cksum.zc_word[0],
 		    (unsigned long long) actual_cksum.zc_word[1],
-		    (unsigned long long) actual_cksum.zc_word[2], 
+		    (unsigned long long) actual_cksum.zc_word[2],
 		    (unsigned long long) actual_cksum.zc_word[3]);
       grub_dprintf ("zfs", "expected checksum %016llx %016llx %016llx %016llx\n",
-		    (unsigned long long) zc.zc_word[0], 
+		    (unsigned long long) zc.zc_word[0],
 		    (unsigned long long) zc.zc_word[1],
-		    (unsigned long long) zc.zc_word[2], 
+		    (unsigned long long) zc.zc_word[2],
 		    (unsigned long long) zc.zc_word[3]);
       return grub_error (GRUB_ERR_BAD_FS, N_("checksum verification failed"));
     }
@@ -485,17 +485,17 @@ vdev_uberblock_compare (uberblock_t * ub1, uberblock_t * ub2)
   else
     ub2_endian = GRUB_ZFS_BIG_ENDIAN;
 
-  if (grub_zfs_to_cpu64 (ub1->ub_txg, ub1_endian) 
+  if (grub_zfs_to_cpu64 (ub1->ub_txg, ub1_endian)
       < grub_zfs_to_cpu64 (ub2->ub_txg, ub2_endian))
     return -1;
-  if (grub_zfs_to_cpu64 (ub1->ub_txg, ub1_endian) 
+  if (grub_zfs_to_cpu64 (ub1->ub_txg, ub1_endian)
       > grub_zfs_to_cpu64 (ub2->ub_txg, ub2_endian))
     return 1;
 
-  if (grub_zfs_to_cpu64 (ub1->ub_timestamp, ub1_endian) 
+  if (grub_zfs_to_cpu64 (ub1->ub_timestamp, ub1_endian)
       < grub_zfs_to_cpu64 (ub2->ub_timestamp, ub2_endian))
     return -1;
-  if (grub_zfs_to_cpu64 (ub1->ub_timestamp, ub1_endian) 
+  if (grub_zfs_to_cpu64 (ub1->ub_timestamp, ub1_endian)
       > grub_zfs_to_cpu64 (ub2->ub_timestamp, ub2_endian))
     return 1;
 
@@ -573,7 +573,7 @@ find_bestub (uberblock_phys_t * ub_array,
 	  grub_errno = GRUB_ERR_NONE;
 	  continue;
 	}
-      if (ubbest == NULL 
+      if (ubbest == NULL
 	  || vdev_uberblock_compare (&(ubptr->ubp_uberblock),
 				     &(ubbest->ubp_uberblock)) > 0)
 	ubbest = ubptr;
@@ -594,10 +594,10 @@ get_psize (blkptr_t * bp, grub_zfs_endian_t endian)
 static grub_uint64_t
 dva_get_offset (const dva_t *dva, grub_zfs_endian_t endian)
 {
-  grub_dprintf ("zfs", "dva=%llx, %llx\n", 
-		(unsigned long long) dva->dva_word[0], 
+  grub_dprintf ("zfs", "dva=%llx, %llx\n",
+		(unsigned long long) dva->dva_word[0],
 		(unsigned long long) dva->dva_word[1]);
-  return grub_zfs_to_cpu64 ((dva)->dva_word[1], 
+  return grub_zfs_to_cpu64 ((dva)->dva_word[1],
 			    endian) << SPA_MINBLOCKSHIFT;
 }
 
@@ -720,7 +720,7 @@ fill_vdev_info_real (struct grub_zfs_data *data,
       if (!fill->children)
 	{
 	  fill->n_children = nelm;
-	  
+
 	  fill->children = grub_zalloc (fill->n_children
 					* sizeof (fill->children[0]));
 	}
@@ -839,7 +839,7 @@ nvlist_next_nvpair (const char *nvl, const char *nvpair)
     {
       /* skip over header, nvl_version and nvl_nvflag */
       nvpair = nvl + 4 * 3;
-    } 
+    }
   else
     {
       /* skip to the next nvpair */
@@ -873,10 +873,10 @@ nvlist_next_nvpair (const char *nvl, const char *nvpair)
   name_len = grub_be_to_cpu32 (grub_get_unaligned32 (nvp));
   nvp += 4;
 
-  nvp = nvp + ((name_len + 3) & ~3); // align 
-  if (nvp + 4 >= nvl + VDEV_PHYS_SIZE                        
+  nvp = nvp + ((name_len + 3) & ~3); // align
+  if (nvp + 4 >= nvl + VDEV_PHYS_SIZE
       || encode_size < 0
-      || nvp + 4 + encode_size > nvl + VDEV_PHYS_SIZE)       
+      || nvp + 4 + encode_size > nvl + VDEV_PHYS_SIZE)
     {
       grub_dprintf ("zfs", "nvlist overflow\n");
       grub_error (GRUB_ERR_BAD_FS, "incorrect nvlist");
@@ -896,7 +896,7 @@ nvpair_name (const char *nvp, char **buf, grub_size_t *buflen)
 {
   /* skip over encode/decode size */
   nvp += 4 * 2;
-	
+
   *buf = (char *) (nvp + 4);
   *buflen = grub_be_to_cpu32 (grub_get_unaligned32 (nvp));
 
@@ -943,7 +943,7 @@ nvpair_value (const char *nvp,char **val,
 
   /* skip over name */
   nvp = nvp + ((name_len + 3) & ~3); /* align */
-	
+
   /* skip over type */
   nvp += 4;
   nelm = grub_be_to_cpu32 (grub_get_unaligned32 (nvp));
@@ -957,7 +957,7 @@ nvpair_value (const char *nvp,char **val,
   *size_out = encode_size;
   if (nelm_out)
     *nelm_out = nelm;
-	    
+
   return 1;
 }
 
@@ -1183,7 +1183,7 @@ scan_disk (grub_device_t dev, struct grub_zfs_data *data,
       desc.vdev_phys_sector
 	= label * (sizeof (vdev_label_t) >> SPA_MINBLOCKSHIFT)
 	+ ((VDEV_SKIP_SIZE + VDEV_BOOT_HEADER_SIZE) >> SPA_MINBLOCKSHIFT)
-	+ (label < VDEV_LABELS / 2 ? 0 : 
+	+ (label < VDEV_LABELS / 2 ? 0 :
 	   ALIGN_DOWN (grub_disk_native_sectors (dev->disk), sizeof (vdev_label_t))
 	   - VDEV_LABELS * (sizeof (vdev_label_t) >> SPA_MINBLOCKSHIFT));
 
@@ -1229,7 +1229,7 @@ scan_disk (grub_device_t dev, struct grub_zfs_data *data,
       grub_free (bh);
       return GRUB_ERR_NONE;
     }
-  
+
   grub_free (ub_array);
   grub_free (bh);
 
@@ -1269,7 +1269,7 @@ scan_devices_iter (const char *name, void *hook_data)
 
   if (!inserted)
     grub_device_close (dev);
-  
+
   return 0;
 }
 
@@ -1386,7 +1386,7 @@ recovery (grub_uint8_t *bufs[4], grub_size_t s, const int nbufs,
 	for (i = 0; i < nbufs; i++)
 	  {
 	    grub_uint8_t mul;
-	    for (j = i; j < nbufs; j++)	    
+	    for (j = i; j < nbufs; j++)
 	      if (matrix1[i][j])
 		break;
 	    if (j == nbufs)
@@ -1453,7 +1453,7 @@ recovery (grub_uint8_t *bufs[4], grub_size_t s, const int nbufs,
       }
     default:
       return grub_error (GRUB_ERR_BUG, "too big matrix");
-    }      
+    }
 }
 
 static grub_err_t
@@ -1510,7 +1510,7 @@ read_device (grub_uint64_t offset, struct grub_zfs_device_desc *desc,
 	int idx, orig_idx;
 
 	if (desc->nparity < 1 || desc->nparity > 3)
-	  return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET, 
+	  return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
 			     "raidz%d is not supported", desc->nparity);
 
 	if (desc->n_children <= desc->nparity || desc->n_children < 1)
@@ -1659,7 +1659,7 @@ read_device (grub_uint64_t offset, struct grub_zfs_device_desc *desc,
 		len -= csize;
 		idx--;
 	      }
-	    for (i = 0; i < failed_devices 
+	    for (i = 0; i < failed_devices
 		   && recovery_len[i] == recovery_len[0];
 		 i++);
 	    /* Since the chunks have variable length handle the last block
@@ -1782,7 +1782,7 @@ zio_read_gang (blkptr_t * bp, grub_zfs_endian_t endian, dva_t * dva, void *buf,
  * Read in a block of raw data to buf.
  */
 static grub_err_t
-zio_read_data (blkptr_t * bp, grub_zfs_endian_t endian, void *buf, 
+zio_read_data (blkptr_t * bp, grub_zfs_endian_t endian, void *buf,
 	       struct grub_zfs_data *data)
 {
   int i, psize;
@@ -1850,7 +1850,7 @@ decode_embedded_bp_compressed(const blkptr_t *bp, void *buf)
  * and put the uncompressed data in buf.
  */
 static grub_err_t
-zio_read (blkptr_t *bp, grub_zfs_endian_t endian, void **buf, 
+zio_read (blkptr_t *bp, grub_zfs_endian_t endian, void **buf,
 	  grub_size_t *size, struct grub_zfs_data *data)
 {
   grub_size_t lsize, psize;
@@ -1936,7 +1936,7 @@ zio_read (blkptr_t *bp, grub_zfs_endian_t endian, void **buf,
   if (encrypted)
     {
       if (!grub_zfs_decrypt)
-	err = grub_error (GRUB_ERR_BAD_FS, 
+	err = grub_error (GRUB_ERR_BAD_FS,
 			  N_("module `%s' isn't loaded"),
 			  "zfscrypt");
       else
@@ -1960,7 +1960,7 @@ zio_read (blkptr_t *bp, grub_zfs_endian_t endian, void **buf,
 					       endian));
 	      return grub_error (GRUB_ERR_BAD_FS, "no key found in keychain");
 	    }
-	  grub_dprintf ("zfs", "using key %u (%" PRIxGRUB_UINT64_T 
+	  grub_dprintf ("zfs", "using key %u (%" PRIxGRUB_UINT64_T
 			", %p) for txg %" PRIxGRUB_UINT64_T "\n",
 			besti, data->subvol.keyring[besti].txg,
 			data->subvol.keyring[besti].cipher,
@@ -2008,7 +2008,7 @@ zio_read (blkptr_t *bp, grub_zfs_endian_t endian, void **buf,
  *
  */
 static grub_err_t
-dmu_read (dnode_end_t * dn, grub_uint64_t blkid, void **buf, 
+dmu_read (dnode_end_t * dn, grub_uint64_t blkid, void **buf,
 	  grub_zfs_endian_t *endian_out, struct grub_zfs_data *data)
 {
   int level;
@@ -2038,8 +2038,8 @@ dmu_read (dnode_end_t * dn, grub_uint64_t blkid, void **buf,
 
       if (BP_IS_HOLE (bp))
 	{
-	  grub_size_t size = grub_zfs_to_cpu16 (dn->dn.dn_datablkszsec, 
-						dn->endian) 
+	  grub_size_t size = grub_zfs_to_cpu16 (dn->dn.dn_datablkszsec,
+						dn->endian)
 	    << SPA_MINBLOCKSHIFT;
 	  *buf = grub_malloc (size);
 	  if (!*buf)
@@ -2103,7 +2103,7 @@ mzap_lookup (mzap_phys_t * zapobj, grub_zfs_endian_t endian,
 }
 
 static int
-mzap_iterate (mzap_phys_t * zapobj, grub_zfs_endian_t endian, int objsize, 
+mzap_iterate (mzap_phys_t * zapobj, grub_zfs_endian_t endian, int objsize,
 	      int (*hook) (const char *name, grub_uint64_t val,
 			   struct grub_zfs_dir_ctx *ctx),
 	      struct grub_zfs_dir_ctx *ctx)
@@ -2117,7 +2117,7 @@ mzap_iterate (mzap_phys_t * zapobj, grub_zfs_endian_t endian, int objsize,
       grub_dprintf ("zfs", "zap: name = %s, value = %llx, cd = %x\n",
 		    mzap_ent[i].mze_name, (long long)mzap_ent[i].mze_value,
 		    (int)mzap_ent[i].mze_cd);
-      if (hook (mzap_ent[i].mze_name, 
+      if (hook (mzap_ent[i].mze_name,
 		grub_zfs_to_cpu64 (mzap_ent[i].mze_value, endian), ctx))
 	return 1;
     }
@@ -2178,12 +2178,12 @@ name_cmp (const char *s1, const char *s2, grub_size_t n,
 
   if (!case_insensitive)
     return grub_memcmp (t1, t2, n);
-      
+
   while (n--)
     {
       if (grub_toupper (*t1) != grub_toupper (*t2))
 	return (int) grub_toupper (*t1) - (int) grub_toupper (*t2);
-	  
+
       t1++;
       t2++;
     }
@@ -2221,7 +2221,7 @@ zap_leaf_array_equal (zap_leaf_phys_t * l, grub_zfs_endian_t endian,
 
 /* XXX */
 static grub_err_t
-zap_leaf_array_get (zap_leaf_phys_t * l, grub_zfs_endian_t endian, int blksft, 
+zap_leaf_array_get (zap_leaf_phys_t * l, grub_zfs_endian_t endian, int blksft,
 		    int chunk, grub_size_t array_len, char *buf)
 {
   grub_size_t bseen = 0;
@@ -2285,7 +2285,7 @@ zap_leaf_lookup (zap_leaf_phys_t * l, grub_zfs_endian_t endian,
 
       grub_dprintf ("zfs", "fzap: length %d\n", (int) le->le_name_length);
 
-      if (zap_leaf_array_equal (l, endian, blksft, 
+      if (zap_leaf_array_equal (l, endian, blksft,
 				grub_zfs_to_cpu16 (le->le_name_chunk,endian),
 				grub_zfs_to_cpu16 (le->le_name_length, endian),
 				name, case_insensitive))
@@ -2334,7 +2334,7 @@ fzap_lookup (dnode_end_t * zap_dnode, zap_phys_t * zap,
 {
   void *l;
   grub_uint64_t hash, idx, blkid;
-  int blksft = zfs_log2 (grub_zfs_to_cpu16 (zap_dnode->dn.dn_datablkszsec, 
+  int blksft = zfs_log2 (grub_zfs_to_cpu16 (zap_dnode->dn.dn_datablkszsec,
 					    zap_dnode->endian) << DNODE_SHIFT);
   grub_err_t err;
   grub_zfs_endian_t leafendian;
@@ -2347,7 +2347,7 @@ fzap_lookup (dnode_end_t * zap_dnode, zap_phys_t * zap,
 
   /* get block id from index */
   if (zap->zap_ptrtbl.zt_numblks != 0)
-    return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET, 
+    return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
 		       "external pointer tables not supported");
   idx = ZAP_HASH_IDX (hash, zap->zap_ptrtbl.zt_shift);
   blkid = grub_zfs_to_cpu64 (((grub_uint64_t *) zap)[idx + (1 << (blksft - 3 - 1))], zap_dnode->endian);
@@ -2379,7 +2379,7 @@ fzap_iterate (dnode_end_t * zap_dnode, zap_phys_t * zap,
   void *l_in;
   grub_uint64_t idx, idx2, blkid;
   grub_uint16_t chunk;
-  int blksft = zfs_log2 (grub_zfs_to_cpu16 (zap_dnode->dn.dn_datablkszsec, 
+  int blksft = zfs_log2 (grub_zfs_to_cpu16 (zap_dnode->dn.dn_datablkszsec,
 					    zap_dnode->endian) << DNODE_SHIFT);
   grub_err_t err;
   grub_zfs_endian_t endian;
@@ -2390,7 +2390,7 @@ fzap_iterate (dnode_end_t * zap_dnode, zap_phys_t * zap,
   /* get block id from index */
   if (zap->zap_ptrtbl.zt_numblks != 0)
     {
-      grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET, 
+      grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
 		  "external pointer tables not supported");
       return 0;
     }
@@ -2517,7 +2517,7 @@ zap_lookup (dnode_end_t * zap_dnode, const char *name, grub_uint64_t *val,
       grub_dprintf ("zfs", "micro zap\n");
       err = mzap_lookup (zapbuf, endian, size, name, val,
 			 case_insensitive);
-      grub_dprintf ("zfs", "returned %d\n", err);      
+      grub_dprintf ("zfs", "returned %d\n", err);
       grub_free (zapbuf);
       return err;
     }
@@ -2527,7 +2527,7 @@ zap_lookup (dnode_end_t * zap_dnode, const char *name, grub_uint64_t *val,
       /* this is a fat zap */
       err = fzap_lookup (zap_dnode, zapbuf, name, val, data,
 			 case_insensitive);
-      grub_dprintf ("zfs", "returned %d\n", err);      
+      grub_dprintf ("zfs", "returned %d\n", err);
       grub_free (zapbuf);
       return err;
     }
@@ -2560,7 +2560,7 @@ zap_iterate_u64_transform (const void *name,
 }
 
 static int
-zap_iterate_u64 (dnode_end_t * zap_dnode, 
+zap_iterate_u64 (dnode_end_t * zap_dnode,
 		 int (*hook) (const char *name, grub_uint64_t val,
 			      struct grub_zfs_dir_ctx *ctx),
 		 struct grub_zfs_data *data, struct grub_zfs_dir_ctx *ctx)
@@ -2607,7 +2607,7 @@ zap_iterate_u64 (dnode_end_t * zap_dnode,
 }
 
 static int
-zap_iterate (dnode_end_t * zap_dnode, 
+zap_iterate (dnode_end_t * zap_dnode,
 	     grub_size_t nameelemlen,
 	     int (*hook) (const void *name, grub_size_t namelen,
 			  const void *val_in,
@@ -2667,7 +2667,7 @@ dnode_get (dnode_end_t * mdn, grub_uint64_t objnum, grub_uint8_t type,
   grub_err_t err;
   grub_zfs_endian_t endian;
 
-  blksz = grub_zfs_to_cpu16 (mdn->dn.dn_datablkszsec, 
+  blksz = grub_zfs_to_cpu16 (mdn->dn.dn_datablkszsec,
 			     mdn->endian) << SPA_MINBLOCKSHIFT;
   epbs = zfs_log2 (blksz) - DNODE_SHIFT;
 
@@ -2678,18 +2678,18 @@ dnode_get (dnode_end_t * mdn, grub_uint64_t objnum, grub_uint8_t type,
   blkid = objnum >> epbs;
   idx = objnum & ((1 << epbs) - 1);
 
-  if (data->dnode_buf != NULL && grub_memcmp (data->dnode_mdn, mdn, 
-					      sizeof (*mdn)) == 0 
+  if (data->dnode_buf != NULL && grub_memcmp (data->dnode_mdn, mdn,
+					      sizeof (*mdn)) == 0
       && objnum >= data->dnode_start && objnum < data->dnode_end)
     {
       grub_memmove (&(buf->dn), &(data->dnode_buf)[idx], DNODE_SIZE);
       buf->endian = data->dnode_endian;
-      if (type && buf->dn.dn_type != type) 
-	return grub_error(GRUB_ERR_BAD_FS, "incorrect dnode type"); 
+      if (type && buf->dn.dn_type != type)
+	return grub_error(GRUB_ERR_BAD_FS, "incorrect dnode type");
       return GRUB_ERR_NONE;
     }
 
-  grub_dprintf ("zfs", "endian = %d, blkid=%llx\n", mdn->endian, 
+  grub_dprintf ("zfs", "endian = %d, blkid=%llx\n", mdn->endian,
 		(unsigned long long) blkid);
   err = dmu_read (mdn, blkid, &dnbuf, &endian, data);
   if (err)
@@ -2715,8 +2715,8 @@ dnode_get (dnode_end_t * mdn, grub_uint64_t objnum, grub_uint8_t type,
 
   grub_memmove (&(buf->dn), (dnode_phys_t *) dnbuf + idx, DNODE_SIZE);
   buf->endian = endian;
-  if (type && buf->dn.dn_type != type) 
-    return grub_error(GRUB_ERR_BAD_FS, "incorrect dnode type"); 
+  if (type && buf->dn.dn_type != type)
+    return grub_error(GRUB_ERR_BAD_FS, "incorrect dnode type");
 
   return GRUB_ERR_NONE;
 }
@@ -2740,7 +2740,7 @@ dnode_get_path (struct subvolume *subvol, const char *path_in, dnode_end_t *dn,
   struct dnode_chain
   {
     struct dnode_chain *next;
-    dnode_end_t dn; 
+    dnode_end_t dn;
   };
   struct dnode_chain *dnode_path = 0, *dn_new, *root;
 
@@ -2750,7 +2750,7 @@ dnode_get_path (struct subvolume *subvol, const char *path_in, dnode_end_t *dn,
   dn_new->next = 0;
   dnode_path = root = dn_new;
 
-  err = dnode_get (&subvol->mdn, MASTER_NODE_OBJ, DMU_OT_MASTER_NODE, 
+  err = dnode_get (&subvol->mdn, MASTER_NODE_OBJ, DMU_OT_MASTER_NODE,
 		   &(dnode_path->dn), data);
   if (err)
     {
@@ -2801,7 +2801,7 @@ dnode_get_path (struct subvolume *subvol, const char *path_in, dnode_end_t *dn,
       grub_free (dn_new);
       return grub_errno;
     }
-  
+
   while (1)
     {
       /* skip leading slashes */
@@ -2827,7 +2827,7 @@ dnode_get_path (struct subvolume *subvol, const char *path_in, dnode_end_t *dn,
 	    }
 	  else
 	    {
-	      err = grub_error (GRUB_ERR_FILE_NOT_FOUND, 
+	      err = grub_error (GRUB_ERR_FILE_NOT_FOUND,
 				"can't resolve ..");
 	      break;
 	    }
@@ -2877,7 +2877,7 @@ dnode_get_path (struct subvolume *subvol, const char *path_in, dnode_end_t *dn,
 	    {
 	      grub_size_t block;
 	      grub_size_t blksz;
-	      blksz = (grub_zfs_to_cpu16 (dnode_path->dn.dn.dn_datablkszsec, 
+	      blksz = (grub_zfs_to_cpu16 (dnode_path->dn.dn.dn_datablkszsec,
 					  dnode_path->dn.endian)
 		       << SPA_MINBLOCKSHIFT);
 
@@ -2916,7 +2916,7 @@ dnode_get_path (struct subvolume *subvol, const char *path_in, dnode_end_t *dn,
 		if (err)
 		  break;
 	      free_symval = 1;
-	    }	    
+	    }
 	  path = path_buf = grub_malloc (sym_sz + grub_strlen (oldpath) + 1);
 	  if (!path_buf)
 	    {
@@ -2930,9 +2930,9 @@ dnode_get_path (struct subvolume *subvol, const char *path_in, dnode_end_t *dn,
 	  if (free_symval)
 	    grub_free (sym_value);
 	  path [sym_sz] = 0;
-	  grub_memcpy (path + grub_strlen (path), oldpath, 
+	  grub_memcpy (path + grub_strlen (path), oldpath,
 		       grub_strlen (oldpath) + 1);
-	  
+
 	  grub_free (oldpathbuf);
 	  if (path[0] != '/')
 	    {
@@ -2951,7 +2951,7 @@ dnode_get_path (struct subvolume *subvol, const char *path_in, dnode_end_t *dn,
 	{
 	  void *sahdrp;
 	  int hdrsize;
-	  
+
 	  if (dnode_path->dn.dn.dn_bonuslen != 0)
 	    {
 	      sahdrp = DN_BONUS (&dnode_path->dn.dn);
@@ -2959,7 +2959,7 @@ dnode_get_path (struct subvolume *subvol, const char *path_in, dnode_end_t *dn,
 	  else if (dnode_path->dn.dn.dn_flags & DNODE_FLAG_SPILL_BLKPTR)
 	    {
 	      blkptr_t *bp = &dnode_path->dn.dn.dn_spill;
-	      
+
 	      err = zio_read (bp, dnode_path->dn.endian, &sahdrp, NULL, data);
 	      if (err)
 	        break;
@@ -2978,7 +2978,7 @@ dnode_get_path (struct subvolume *subvol, const char *path_in, dnode_end_t *dn,
 				   dnode_path->dn.endian) >> 12) & 0xf) == 0xa)
 	    {
 	      char *sym_value = (char *) sahdrp + hdrsize + SA_SYMLINK_OFFSET;
-	      grub_size_t sym_sz = 
+	      grub_size_t sym_sz =
 		grub_zfs_to_cpu64 (grub_get_unaligned64 ((char *) sahdrp
 							 + hdrsize
 							 + SA_SIZE_OFFSET),
@@ -2993,9 +2993,9 @@ dnode_get_path (struct subvolume *subvol, const char *path_in, dnode_end_t *dn,
 		}
 	      grub_memcpy (path, sym_value, sym_sz);
 	      path [sym_sz] = 0;
-	      grub_memcpy (path + grub_strlen (path), oldpath, 
+	      grub_memcpy (path + grub_strlen (path), oldpath,
 			   grub_strlen (oldpath) + 1);
-	      
+
 	      grub_free (oldpathbuf);
 	      if (path[0] != '/')
 		{
@@ -3096,7 +3096,7 @@ get_filesystem_dnode (dnode_end_t * mosmdn, char *fsname,
 
   grub_dprintf ("zfs", "endian = %d\n", mosmdn->endian);
 
-  err = dnode_get (mosmdn, DMU_POOL_DIRECTORY_OBJECT, 
+  err = dnode_get (mosmdn, DMU_POOL_DIRECTORY_OBJECT,
 		   DMU_OT_OBJECT_DIRECTORY, mdn, data);
   if (err)
     return err;
@@ -3119,7 +3119,7 @@ get_filesystem_dnode (dnode_end_t * mosmdn, char *fsname,
     {
       grub_uint64_t childobj;
       char *cname, ch;
- 
+
       while (*fsname == '/')
 	fsname++;
 
@@ -3279,7 +3279,7 @@ dnode_get_fullpath (const char *fullpath, struct subvolume *subvol,
 	filename = ptr_slash;
       else
 	filename = "/";
-      grub_dprintf ("zfs", "fsname = '%s' snapname='%s' filename = '%s'\n", 
+      grub_dprintf ("zfs", "fsname = '%s' snapname='%s' filename = '%s'\n",
 		    fsname, snapname, filename);
     }
   grub_dprintf ("zfs", "alive\n");
@@ -3365,7 +3365,7 @@ dnode_get_fullpath (const char *fullpath, struct subvolume *subvol,
 
       snapobj = grub_zfs_to_cpu64 (((dsl_dataset_phys_t *) DN_BONUS (&subvol->mdn.dn))->ds_snapnames_zapobj, subvol->mdn.endian);
 
-      err = dnode_get (&(data->mos), snapobj, 
+      err = dnode_get (&(data->mos), snapobj,
 		       DMU_OT_DSL_DS_SNAP_MAP, &subvol->mdn, data);
       if (!err)
 	err = zap_lookup (&subvol->mdn, snapname, &headobj, data, 0);
@@ -3383,13 +3383,13 @@ dnode_get_fullpath (const char *fullpath, struct subvolume *subvol,
   subvol->obj = headobj;
 
   make_mdn (&subvol->mdn, data);
-  
+
   grub_dprintf ("zfs", "endian = %d\n", subvol->mdn.endian);
 
   if (*isfs)
     {
       grub_free (fsname);
-      grub_free (snapname);      
+      grub_free (snapname);
       return GRUB_ERR_NONE;
     }
   err = dnode_get_path (subvol, filename, dn, data);
@@ -3409,9 +3409,9 @@ nvlist_find_value (const char *nvlist_in, const char *name,
   char *nvp_name;
 
   /* Verify if the 1st and 2nd byte in the nvlist are valid. */
-  /* NOTE: independently of what endianness header announces all 
+  /* NOTE: independently of what endianness header announces all
      subsequent values are big-endian.  */
-  if (nvlist[0] != NV_ENCODE_XDR || (nvlist[1] != NV_LITTLE_ENDIAN 
+  if (nvlist[0] != NV_ENCODE_XDR || (nvlist[1] != NV_LITTLE_ENDIAN
 				     && nvlist[1] != NV_BIG_ENDIAN))
     {
       grub_dprintf ("zfs", "incorrect nvlist header\n");
@@ -3532,13 +3532,13 @@ get_nvlist_size (const char *beg, const char *limit)
 {
   const char *ptr;
   grub_uint32_t encode_size;
-  
+
   ptr = beg + 8;
 
   while (ptr < limit
 	 && (encode_size = grub_be_to_cpu32 (grub_get_unaligned32 (ptr))))
     ptr += encode_size;	/* goto the next nvpair */
-  ptr += 8;      
+  ptr += 8;
   return (ptr > limit) ? -1 : (ptr - beg);
 }
 
@@ -3674,8 +3674,8 @@ zfs_mount (grub_device_t dev)
     }
 
   ub = &(data->current_uberblock);
-  ub_endian = (grub_zfs_to_cpu64 (ub->ub_magic, 
-				  GRUB_ZFS_LITTLE_ENDIAN) == UBERBLOCK_MAGIC 
+  ub_endian = (grub_zfs_to_cpu64 (ub->ub_magic,
+				  GRUB_ZFS_LITTLE_ENDIAN) == UBERBLOCK_MAGIC
 	       ? GRUB_ZFS_LITTLE_ENDIAN : GRUB_ZFS_BIG_ENDIAN);
 
   err = zio_read (&ub->ub_rootbp, ub_endian,
@@ -3728,7 +3728,7 @@ grub_zfs_fetch_nvlist (grub_device_t dev, char **nvlist)
   return err;
 }
 
-static grub_err_t 
+static grub_err_t
 zfs_label (grub_device_t device, char **label)
 {
   char *nvlist;
@@ -3740,7 +3740,7 @@ zfs_label (grub_device_t device, char **label)
     return grub_errno;
 
   err = zfs_fetch_nvlist (data->device_original, &nvlist);
-  if (err)      
+  if (err)
     {
       zfs_unmount (data);
       return err;
@@ -3752,7 +3752,7 @@ zfs_label (grub_device_t device, char **label)
   return grub_errno;
 }
 
-static grub_err_t 
+static grub_err_t
 zfs_uuid (grub_device_t device, char **uuid)
 {
   struct grub_zfs_data *data;
@@ -3770,7 +3770,7 @@ zfs_uuid (grub_device_t device, char **uuid)
   return GRUB_ERR_NONE;
 }
 
-static grub_err_t 
+static grub_err_t
 zfs_mtime (grub_device_t device, grub_int64_t *mt)
 {
   struct grub_zfs_data *data;
@@ -3784,8 +3784,8 @@ zfs_mtime (grub_device_t device, grub_int64_t *mt)
     return grub_errno;
 
   ub = &(data->current_uberblock);
-  ub_endian = (grub_zfs_to_cpu64 (ub->ub_magic, 
-				  GRUB_ZFS_LITTLE_ENDIAN) == UBERBLOCK_MAGIC 
+  ub_endian = (grub_zfs_to_cpu64 (ub->ub_magic,
+				  GRUB_ZFS_LITTLE_ENDIAN) == UBERBLOCK_MAGIC
 	       ? GRUB_ZFS_LITTLE_ENDIAN : GRUB_ZFS_BIG_ENDIAN);
 
   *mt = grub_zfs_to_cpu64 (ub->ub_timestamp, ub_endian);
@@ -3823,7 +3823,7 @@ grub_zfs_open (struct grub_file *file, const char *fsfilename)
     }
 
   /* We found the dnode for this file. Verify if it is a plain file. */
-  if (data->dnode.dn.dn_type != DMU_OT_PLAIN_FILE_CONTENTS) 
+  if (data->dnode.dn.dn_type != DMU_OT_PLAIN_FILE_CONTENTS)
     {
       zfs_unmount (data);
       return grub_error (GRUB_ERR_BAD_FILE_TYPE, N_("not a regular file"));
@@ -3898,7 +3898,7 @@ grub_zfs_read (grub_file_t file, char *buf, grub_size_t len)
       return len;
     }
 
-  blksz = grub_zfs_to_cpu16 (data->dnode.dn.dn_datablkszsec, 
+  blksz = grub_zfs_to_cpu16 (data->dnode.dn.dn_datablkszsec,
 			     data->dnode.endian) << SPA_MINBLOCKSHIFT;
 
   if (blksz == 0)
@@ -3991,11 +3991,11 @@ fill_fs_info (struct grub_dirhook_info *info,
   dnode_end_t dn;
   grub_uint64_t objnum;
   grub_uint64_t headobj;
-  
+
   grub_memset (info, 0, sizeof (*info));
-    
+
   info->dir = 1;
-  
+
   if (mdn.dn.dn_type == DMU_OT_DSL_DIR)
     {
       headobj = grub_zfs_to_cpu64 (((dsl_dir_phys_t *) DN_BONUS (&mdn.dn))->dd_head_dataset_obj, mdn.endian);
@@ -4010,28 +4010,28 @@ fill_fs_info (struct grub_dirhook_info *info,
   err = make_mdn (&mdn, data);
   if (err)
     return err;
-  err = dnode_get (&mdn, MASTER_NODE_OBJ, DMU_OT_MASTER_NODE, 
+  err = dnode_get (&mdn, MASTER_NODE_OBJ, DMU_OT_MASTER_NODE,
 		   &dn, data);
   if (err)
     {
       grub_dprintf ("zfs", "failed here\n");
       return err;
     }
-  
+
   err = zap_lookup (&dn, ZFS_ROOT_OBJ, &objnum, data, 0);
   if (err)
     {
       grub_dprintf ("zfs", "failed here\n");
       return err;
     }
-  
+
   err = dnode_get (&mdn, objnum, 0, &dn, data);
   if (err)
     {
       grub_dprintf ("zfs", "failed here\n");
       return err;
     }
-  
+
   if (dn.dn.dn_bonustype == DMU_OT_SA)
     {
       void *sahdrp;
@@ -4117,15 +4117,15 @@ iterate_zap (const char *name, grub_uint64_t val, struct grub_zfs_dir_ctx *ctx)
       info.mtime = grub_zfs_to_cpu64 (grub_get_unaligned64 ((char *) sahdrp + hdrsize + SA_MTIME_OFFSET), dn.endian);
       info.case_insensitive = ctx->data->subvol.case_insensitive;
     }
-  
+
   if (dn.dn.dn_bonustype == DMU_OT_ZNODE)
-    {	
+    {
       info.mtimeset = 1;
       info.mtime = grub_zfs_to_cpu64 (((znode_phys_t *) DN_BONUS (&dn.dn))->zp_mtime[0],
 				      dn.endian);
     }
   info.dir = (dn.dn.dn_type == DMU_OT_DIRECTORY_CONTENTS);
-  grub_dprintf ("zfs", "type=%d, name=%s\n", 
+  grub_dprintf ("zfs", "type=%d, name=%s\n",
 		(int)dn.dn.dn_type, (char *)name);
   return ctx->hook (name, &info, ctx->hook_data);
 }
@@ -4219,7 +4219,7 @@ grub_zfs_dir (grub_device_t device, const char *path,
 
   if (isfs)
     {
-      grub_uint64_t childobj, headobj; 
+      grub_uint64_t childobj, headobj;
       grub_uint64_t snapobj;
       dnode_end_t dn;
       struct grub_dirhook_info info;
@@ -4247,7 +4247,7 @@ grub_zfs_dir (grub_device_t device, const char *path,
 	}
 
       zap_iterate_u64 (&dn, iterate_zap_fs, data, &ctx);
-      
+
       err = dnode_get (&(data->mos), headobj, DMU_OT_DSL_DATASET, &dn, data);
       if (err)
 	{
@@ -4289,8 +4289,8 @@ check_feature (const char *name, grub_uint64_t val,
     return 0;
   if (name[0] == 0)
     return 0;
-  for (i = 0; spa_feature_names[i] != NULL; i++) 
-    if (grub_strcmp (name, spa_feature_names[i]) == 0) 
+  for (i = 0; spa_feature_names[i] != NULL; i++)
+    if (grub_strcmp (name, spa_feature_names[i]) == 0)
       return 0;
   return 1;
 }
@@ -4303,7 +4303,7 @@ check_feature (const char *name, grub_uint64_t val,
  *	0: Success.
  *	errnum: Failure.
  */
-	    	   
+
 static grub_err_t
 check_mos_features(dnode_phys_t *mosmdn_phys,grub_zfs_endian_t endian,struct grub_zfs_data* data )
 {
@@ -4328,7 +4328,7 @@ check_mos_features(dnode_phys_t *mosmdn_phys,grub_zfs_endian_t endian,struct gru
   errnum = zap_lookup(&dn, DMU_POOL_FEATURES_FOR_READ, &objnum, data,0);
   if (errnum != 0)
     return errnum;
-  
+
   errnum = dnode_get(&mosmdn, objnum, DMU_OTN_ZAP_METADATA, &dn, data);
   if (errnum != 0)
     return errnum;
diff --git a/grub-core/fs/zfs/zfs_fletcher.c b/grub-core/fs/zfs/zfs_fletcher.c
index 7d27b053dc7a..ad3be6705479 100644
--- a/grub-core/fs/zfs/zfs_fletcher.c
+++ b/grub-core/fs/zfs/zfs_fletcher.c
@@ -39,14 +39,14 @@
 #include <grub/zfs/dsl_dataset.h>
 
 void
-fletcher_2(const void *buf, grub_uint64_t size, grub_zfs_endian_t endian, 
+fletcher_2(const void *buf, grub_uint64_t size, grub_zfs_endian_t endian,
 	   zio_cksum_t *zcp)
 {
   const grub_uint64_t *ip = buf;
   const grub_uint64_t *ipend = ip + (size / sizeof (grub_uint64_t));
   grub_uint64_t a0, b0, a1, b1;
-  
-  for (a0 = b0 = a1 = b1 = 0; ip < ipend; ip += 2) 
+
+  for (a0 = b0 = a1 = b1 = 0; ip < ipend; ip += 2)
     {
       a0 += grub_zfs_to_cpu64 (ip[0], endian);
       a1 += grub_zfs_to_cpu64 (ip[1], endian);
@@ -61,14 +61,14 @@ fletcher_2(const void *buf, grub_uint64_t size, grub_zfs_endian_t endian,
 }
 
 void
-fletcher_4 (const void *buf, grub_uint64_t size, grub_zfs_endian_t endian, 
+fletcher_4 (const void *buf, grub_uint64_t size, grub_zfs_endian_t endian,
 	    zio_cksum_t *zcp)
 {
   const grub_uint32_t *ip = buf;
   const grub_uint32_t *ipend = ip + (size / sizeof (grub_uint32_t));
   grub_uint64_t a, b, c, d;
-  
-  for (a = b = c = d = 0; ip < ipend; ip++) 
+
+  for (a = b = c = d = 0; ip < ipend; ip++)
     {
       a += grub_zfs_to_cpu32 (ip[0], endian);;
       b += a;
diff --git a/grub-core/fs/zfs/zfs_sha256.c b/grub-core/fs/zfs/zfs_sha256.c
index a181f076c54c..f042fa61ab89 100644
--- a/grub-core/fs/zfs/zfs_sha256.c
+++ b/grub-core/fs/zfs/zfs_sha256.c
@@ -116,23 +116,23 @@ zio_checksum_SHA256(const void *buf, grub_uint64_t size,
   grub_uint8_t pad[128];
   unsigned padsize = size & 63;
   unsigned i;
-  
+
   for (i = 0; i < size - padsize; i += 64)
     SHA256Transform(H, (grub_uint8_t *)buf + i);
-  
+
   for (i = 0; i < padsize; i++)
     pad[i] = ((grub_uint8_t *)buf)[i];
-  
+
   for (pad[padsize++] = 0x80; (padsize & 63) != 56; padsize++)
     pad[padsize] = 0;
-  
+
   for (i = 0; i < 8; i++)
     pad[padsize++] = (size << 3) >> (56 - 8 * i);
-  
+
   for (i = 0; i < padsize && i <= 64; i += 64)
     SHA256Transform(H, pad + i);
-  
-  zcp->zc_word[0] = grub_cpu_to_zfs64 ((grub_uint64_t)H[0] << 32 | H[1], 
+
+  zcp->zc_word[0] = grub_cpu_to_zfs64 ((grub_uint64_t)H[0] << 32 | H[1],
 				       endian);
   zcp->zc_word[1] = grub_cpu_to_zfs64 ((grub_uint64_t)H[2] << 32 | H[3],
 				       endian);
diff --git a/grub-core/fs/zfs/zfscrypt.c b/grub-core/fs/zfs/zfscrypt.c
index de3b015f5827..da30e9ab33dd 100644
--- a/grub-core/fs/zfs/zfscrypt.c
+++ b/grub-core/fs/zfs/zfscrypt.c
@@ -46,7 +46,7 @@
 GRUB_MOD_LICENSE ("GPLv3+");
 
 /*
-  Mostly based on following article: 
+  Mostly based on following article:
   https://blogs.oracle.com/darren/entry/zfs_encryption_what_is_on
  */
 
@@ -179,7 +179,7 @@ grub_gcm_mul (grub_uint8_t *a, const grub_uint8_t *b)
 	grub_crypto_xor (res, res, bs, 16);
       grub_gcm_mul_x (bs);
     }
- 
+
   grub_memcpy (a, res, 16);
 }
 
@@ -275,7 +275,7 @@ algo_decrypt (grub_crypto_cipher_handle_t cipher, grub_uint64_t algo,
 }
 
 static grub_err_t
-grub_zfs_decrypt_real (grub_crypto_cipher_handle_t cipher, 
+grub_zfs_decrypt_real (grub_crypto_cipher_handle_t cipher,
 		       grub_uint64_t algo,
 		       void *nonce,
 		       char *buf, grub_size_t size,
@@ -286,7 +286,7 @@ grub_zfs_decrypt_real (grub_crypto_cipher_handle_t cipher,
   unsigned i;
   grub_uint32_t sw[4];
   gcry_err_code_t err;
-      
+
   grub_memcpy (sw, nonce, 16);
   if (endian != GRUB_ZFS_BIG_ENDIAN)
     for (i = 0; i < 4; i++)
@@ -302,7 +302,7 @@ grub_zfs_decrypt_real (grub_crypto_cipher_handle_t cipher,
 		      sw + 1, 3, 12);
   if (err)
     return grub_crypto_gcry_error (err);
-  
+
   for (i = 0; i < 3; i++)
     if (grub_zfs_to_cpu32 (expected_mac[i], endian)
 	!= grub_be_to_cpu32 (mac[i]))
@@ -362,7 +362,7 @@ grub_zfs_load_key_real (const struct grub_zfs_key *key,
 	  grub_crypto_cipher_close (cipher);
 	  continue;
 	}
-		    
+
       err = grub_crypto_cipher_set_key (cipher, wrap_key_real,
 					keylen);
       if (err)
@@ -371,7 +371,7 @@ grub_zfs_load_key_real (const struct grub_zfs_key *key,
 	  grub_crypto_cipher_close (cipher);
 	  continue;
 	}
-      
+
       err = algo_decrypt (cipher, algo, decrypted, key->unknown_purpose_key, 32,
 			  mac, key->unknown_purpose_nonce, 2, 16);
       if (err || (grub_crypto_memcmp (mac, key->unknown_purpose_key + 32, 16)
